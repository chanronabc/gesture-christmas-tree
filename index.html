<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Christmas Tree | æ‰‹åŠ¿æ§åˆ¶åœ£è¯æ ‘</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #video-input {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 12px;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
            z-index: 2;
            opacity: 0.8;
            border: 2px solid rgba(212, 175, 55, 0.5); /* é‡‘è‰²è¾¹æ¡† */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            object-fit: cover;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* è®©é¼ æ ‡ç©¿é€åˆ°Canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 40px;
            box-sizing: border-box;
        }

        .header {
            color: #D4AF37; /* é‡‘å±é‡‘ */
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-size: 2rem;
        }

        .status-badge {
            display: inline-block;
            margin-top: 10px;
            padding: 6px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
            backdrop-filter: blur(5px);
            background: rgba(0, 0, 0, 0.3);
        }

        .controls {
            pointer-events: auto;
            display: flex;
            gap: 20px;
            align-items: flex-end;
        }

        .btn-upload {
            background: linear-gradient(135deg, #D4AF37 0%, #B8860B 100%);
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 30px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
        }

        .btn-upload:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.6);
        }

        .gesture-guide {
            position: absolute;
            top: 50%;
            right: 40px;
            transform: translateY(-50%);
            color: rgba(255,255,255,0.6);
            text-align: right;
            font-size: 0.9rem;
            line-height: 2;
        }

        .gesture-guide span {
            color: #D4AF37;
            font-weight: bold;
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #050505;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #D4AF37;
            transition: opacity 1s;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(212, 175, 55, 0.3);
            border-top: 3px solid #D4AF37;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        input[type="file"] {
            display: none;
        }
    </style>
    
    <!-- MediaPipe Libraries (Loaded globally to avoid module import issues) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <!-- Import Maps for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <div class="header">
            <h1>Gesture Xmas Tree</h1>
            <div class="status-badge" id="status-text">ç³»ç»Ÿåˆå§‹åŒ–ä¸­...</div>
        </div>
        
        <div class="gesture-guide">
            <p><span>âœŠ æ¡æ‹³</span> -> èšåˆ (æ ‘)</p>
            <p><span>ğŸ– å¼ å¼€</span> -> æ•£å¼€ (äº‘)</p>
            <p><span>ğŸ‘Œ æåˆ</span> -> æŠ“å–ç…§ç‰‡</p>
            <p><span>ğŸ‘‹ ç§»åŠ¨</span> -> æ—‹è½¬è§†è§’</p>
        </div>

        <div class="controls">
            <label for="file-upload" class="btn-upload">ğŸ“· ä¸Šä¼ ç…§ç‰‡ (æ”¯æŒå¤šé€‰)</label>
            <input id="file-upload" type="file" multiple accept="image/*">
        </div>
    </div>

    <!-- WebGL Canvas -->
    <div id="canvas-container"></div>

    <!-- Webcam Input (Hidden but necessary for MediaPipe) -->
    <video id="video-input" playsinline></video>

    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="spinner"></div>
        <p>æ­£åœ¨åŠ è½½è§†è§‰æ¨¡å‹ä¸åœ£è¯é­”æ³•...</p>
    </div>

    <!-- Application Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        
        // --- 1. å…¨å±€é…ç½®ä¸çŠ¶æ€ç®¡ç† ---
        const CONFIG = {
            colors: {
                bg: 0x050505,
                treeGreen: 0x4F7F4F, // åŸºç¡€ç»¿
                gold: 0xFFD700,      // æ­£é‡‘
                red: 0xDC143C,       // çŒ©çº¢
                blue: 0x1E90FF,      // çš‡å®¶è“ (æ–°)
                purple: 0x9932CC,    // ç´«æ°´æ™¶ (æ–°)
                silver: 0xE0E0E0,    // äº®é“¶ (æ–°)
                white: 0xFFFFFF
            },
            particleCount: 800, // ç¨å¾®å¢åŠ ç²’å­æ•°é‡ä»¥å®¹çº³æ›´å¤šè‰²å½©
            photoCount: 12, 
            treeHeight: 25,
            treeRadius: 10
        };

        const STATE = {
            current: 'TREE', // 'TREE', 'SCATTER', 'ZOOM'
            targetRotation: { x: 0, y: 0 },
            currentRotation: { x: 0, y: 0 },
            handDetected: false,
            zoomPhotoIndex: -1, // å½“å‰æ”¾å¤§çš„ç…§ç‰‡ç´¢å¼•
        };

        // --- 2. Three.js åˆå§‹åŒ– ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 40);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        // åå¤„ç† (Bloom/Glow)
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2; // è¾‰å…‰å¼ºåº¦
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- ç¯å…‰ç³»ç»Ÿå‡çº§ ---
        
        // 1. ç¯å¢ƒå…‰ (å¤§å¹…æå‡å¼ºåº¦ï¼Œæ¶ˆé™¤æ­»é»‘)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        // 2. åŠçƒå…‰ (å¢å¼ºå†·æš–å¯¹æ¯”ï¼šå†·è“å¤©å…‰ + æš–åœ°å…‰)
        const hemiLight = new THREE.HemisphereLight(0x4433bb, 0x332200, 0.8);
        scene.add(hemiLight);

        // 3. ä¸»ç‚¹å…‰æº (é‡‘è‰²)
        const pointLight = new THREE.PointLight(CONFIG.colors.gold, 4.0, 150);
        pointLight.position.set(15, 30, 15);
        scene.add(pointLight);
        
        // 4. å‰¯ç‚¹å…‰æº (æ”¹ä¸ºæ´‹çº¢è‰²ï¼Œå¢åŠ è¿·å¹»æ„Ÿ)
        const redLight = new THREE.PointLight(0xFF00FF, 3.0, 100);
        redLight.position.set(-15, 10, 10);
        scene.add(redLight);

        // 5. èšå…‰ç¯ (ä¿®å¤å¹¶å®Œæ•´é…ç½®)
        const spotLight = new THREE.SpotLight(0xffea00, 5);
        spotLight.position.set(0, 50, 20);
        spotLight.angle = Math.PI / 6;
        spotLight.penumbra = 0.5;
        spotLight.decay = 2;
        spotLight.distance = 200;
        spotLight.target.position.set(0, 0, 0);
        scene.add(spotLight);
        scene.add(spotLight.target);

        // --- 3. ç²’å­ä¸å‡ ä½•ä½“æ„å»º ---

        // ã€å…³é”®ä¿®å¤ã€‘å­˜å‚¨æ‰€æœ‰å¯¹è±¡çš„æ•°æ®ç»“æ„
        const objects = []; 
        const dummy = new THREE.Object3D();

        // æè´¨ - å®šä¹‰æ›´å¤šæ ·åŒ–çš„æè´¨
        // åŸºç¡€æè´¨å·¥å‚å‡½æ•°
        function createMaterial(color, emissiveIntensity = 0.5) {
             return new THREE.MeshStandardMaterial({ 
                color: color, 
                roughness: 0.2, 
                metalness: 0.9,
                emissive: color,
                emissiveIntensity: emissiveIntensity
            });
        }

        const matGold = createMaterial(CONFIG.colors.gold, 0.7);
        const matRed = createMaterial(CONFIG.colors.red, 0.6);
        const matBlue = createMaterial(CONFIG.colors.blue, 0.6);
        const matPurple = createMaterial(CONFIG.colors.purple, 0.6);
        const matSilver = createMaterial(CONFIG.colors.silver, 0.5);
        
        // æ ‘å¶æè´¨ (ç¨å¾®å“‘å…‰ä¸€ç‚¹)
        const matGreen = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.treeGreen, 
            roughness: 0.6, 
            metalness: 0.2,
            emissive: 0x052205, 
            emissiveIntensity: 0.2
        });

        const ornamentMaterials = [matGold, matRed, matBlue, matPurple, matSilver];

        // ç»„ï¼šç”¨äºæ•´ä½“æ—‹è½¬
        const treeGroup = new THREE.Group();
        scene.add(treeGroup);

        // åˆ›å»ºè£…é¥°ç‰© (InstancedMesh for performance)
        const spheresGeo = new THREE.SphereGeometry(0.3, 16, 16);
        const cubesGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
        const diamondGeo = new THREE.OctahedronGeometry(0.3); // æ–°å¢ï¼šé’»çŸ³å½¢çŠ¶
        
        // æˆ‘ä»¬ä¸ä½¿ç”¨ InstancedMesh å› ä¸ºæˆ‘ä»¬éœ€è¦æ¯ä¸ªç²’å­å•ç‹¬è¿åŠ¨åˆ°ä¸åŒç›®æ ‡ä½ç½®
        // è™½ç„¶ Mesh æ¶ˆè€—å¤šä¸€ç‚¹ï¼Œä½†ä¸ºäº†æµç•…çš„ morph åŠ¨ç”»ï¼Œè¿™é‡Œä½¿ç”¨ç®€å•çš„ Mesh æ•°ç»„æ›´å®¹æ˜“æ§åˆ¶
        
        function createParticle(index, total) {
            let mesh;
            const rand = Math.random();

            // 70% æ˜¯æ ‘å¶(ç»¿è‰²èƒŒæ™¯)ï¼Œ30% æ˜¯å½©è‰²è£…é¥°
            if (rand > 0.3) {
                // æ ‘å¶ï¼šç»¿è‰²ï¼Œå¸¦ä¸€ç‚¹éšæœºè‰²ç›¸åç§»ï¼Œè®©æ ‘çœ‹èµ·æ¥æ›´è‡ªç„¶
                const tempMat = matGreen.clone();
                // éšæœºå¾®è°ƒé¢œè‰²
                const color = new THREE.Color(CONFIG.colors.treeGreen);
                color.offsetHSL(0, (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1);
                tempMat.color = color;
                tempMat.emissive = color;
                
                mesh = new THREE.Mesh(spheresGeo, tempMat);
            } else {
                // è£…é¥°ç‰©ï¼šéšæœºé€‰æ‹©é¢œè‰²å’Œå½¢çŠ¶
                const mat = ornamentMaterials[Math.floor(Math.random() * ornamentMaterials.length)];
                
                // éšæœºå½¢çŠ¶
                let geo = spheresGeo;
                if (Math.random() > 0.6) geo = cubesGeo; // ç¤¼ç‰©ç›’
                else if (Math.random() > 0.8) geo = diamondGeo; // é’»çŸ³

                mesh = new THREE.Mesh(geo, mat);
            }

            // è®¡ç®—ç›®æ ‡ä½ç½®
            // 1. æ ‘çš„ä½ç½® (åœ†é”¥èºæ—‹)
            const y = (index / total) * CONFIG.treeHeight - CONFIG.treeHeight / 2;
            const progress = (y + CONFIG.treeHeight / 2) / CONFIG.treeHeight;
            const radius = CONFIG.treeRadius * (1 - progress);
            // å¢åŠ ä¸€ç‚¹éšæœºåç§»ï¼Œè®©æ ‘çœ‹èµ·æ¥æ›´è“¬æ¾
            const rOffset = (Math.random() - 0.5) * 0.5; 
            const angle = index * 0.5 + Math.random() * 0.2; // èºæ—‹å¯†åº¦ + éšæœº
            
            const treePos = new THREE.Vector3(
                Math.cos(angle) * (radius + rOffset),
                y,
                Math.sin(angle) * (radius + rOffset)
            );

            // 2. æ•£å¼€çš„ä½ç½® (éšæœºçƒä½“åˆ†å¸ƒ)
            const scatterPos = new THREE.Vector3(
                (Math.random() - 0.5) * 45,
                (Math.random() - 0.5) * 45,
                (Math.random() - 0.5) * 35
            );

            mesh.userData = {
                treePos: treePos,
                scatterPos: scatterPos,
                velocity: new THREE.Vector3(),
                isPhoto: false
            };

            mesh.position.copy(treePos); // åˆå§‹ä½ç½®
            mesh.scale.setScalar(Math.random() * 0.5 + 0.5);
            
            treeGroup.add(mesh);
            objects.push(mesh);
        }

        // ç”Ÿæˆè£…é¥°ç²’å­
        for (let i = 0; i < CONFIG.particleCount; i++) {
            createParticle(i, CONFIG.particleCount);
        }

        // --- 4. ç…§ç‰‡äº‘å¤„ç† ---
        const photoMeshes = [];
        const photoLoader = new THREE.TextureLoader();

        // === æ–°å¢ï¼šé¢„åŠ è½½ç…§ç‰‡ URL æ•°ç»„ ===
        // æ‚¨å¯ä»¥åœ¨è¿™é‡Œæ›¿æ¢ä¸ºæ‚¨è‡ªå·±çš„å›¾ç‰‡é“¾æ¥ (ä¾‹å¦‚å›¾åºŠé“¾æ¥)
        // å¦‚æœæ•°ç»„ä¸ºç©ºæˆ–é“¾æ¥æ— æ•ˆï¼Œå°†è‡ªåŠ¨ä½¿ç”¨é»˜è®¤çš„æ–‡å­—å ä½ç¬¦ã€‚
        const PRELOADED_PHOTOS = [
            'https://picsum.photos/id/1015/500/500', // ç¤ºä¾‹å›¾ç‰‡ 1 (é£æ™¯)
            'https://picsum.photos/id/1025/500/500', // ç¤ºä¾‹å›¾ç‰‡ 2 (åŠ¨ç‰©)
            'https://picsum.photos/id/1035/500/500', // ç¤ºä¾‹å›¾ç‰‡ 3 (äººç‰©)
            // åœ¨è¿™é‡Œæ·»åŠ æ›´å¤šé“¾æ¥...
        ];

        // é»˜è®¤ç…§ç‰‡å ä½ç¬¦ç”Ÿæˆå™¨
        function createTextTexture(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FFF';
            ctx.fillRect(0,0,512,512);
            ctx.fillStyle = '#D4AF37'; // Gold border
            ctx.fillRect(20,20,472,472);
            ctx.fillStyle = '#000';
            ctx.fillRect(30,30,452,452);
            
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 256, 256);
            
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        function addPhoto(texture, index) {
            const geo = new THREE.PlaneGeometry(3, 3);
            const mat = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide 
            });
            const mesh = new THREE.Mesh(geo, mat);

            // æ ‘å½¢ä½ç½®ï¼šåœ¨æ ‘çš„è¡¨é¢éšæœºä½ç½®
            const y = (Math.random()) * CONFIG.treeHeight - CONFIG.treeHeight / 2;
            const progress = (y + CONFIG.treeHeight / 2) / CONFIG.treeHeight;
            const radius = CONFIG.treeRadius * (1 - progress) + 1.5; // ç¨å¾®çªå‡ºä¸€ç‚¹
            const angle = Math.random() * Math.PI * 2;
            
            const treePos = new THREE.Vector3(
                Math.cos(angle) * radius,
                y,
                Math.sin(angle) * radius
            );

            // æ•£å¼€ä½ç½®ï¼šè¾ƒå¤§çš„å¤–å›´
            const scatterPos = new THREE.Vector3(
                (Math.random() - 0.5) * 50,
                (Math.random() - 0.5) * 50,
                (Math.random() - 0.5) * 20
            );

            mesh.userData = {
                treePos: treePos,
                scatterPos: scatterPos,
                isPhoto: true,
                originalScale: 1
            };

            mesh.position.copy(treePos);
            // é¢å‘ä¸­å¿ƒå¤–ä¾§
            mesh.lookAt(new THREE.Vector3(0, y, 0));
            
            treeGroup.add(mesh);
            objects.push(mesh);
            photoMeshes.push(mesh);
        }

        // åˆå§‹åŒ–ç…§ç‰‡ï¼šå°è¯•åŠ è½½é¢„å®šä¹‰ç…§ç‰‡ï¼Œä¸è¶³çš„ç”¨å ä½ç¬¦è¡¥å……
        const initialPhotoCount = Math.max(5, PRELOADED_PHOTOS.length);

        for(let i=0; i < initialPhotoCount; i++) {
            if (i < PRELOADED_PHOTOS.length) {
                // å°è¯•åŠ è½½é¢„å®šä¹‰ç…§ç‰‡
                photoLoader.load(
                    PRELOADED_PHOTOS[i],
                    (texture) => {
                        texture.colorSpace = THREE.SRGBColorSpace;
                        addPhoto(texture, i);
                    },
                    undefined, // onProgress
                    (err) => { // onError
                        console.warn(`æ— æ³•åŠ è½½ç…§ç‰‡: ${PRELOADED_PHOTOS[i]}, ä½¿ç”¨å ä½ç¬¦æ›¿ä»£ã€‚`);
                        addPhoto(createTextTexture(`Memory ${i+1}`), i);
                    }
                );
            } else {
                // ä½¿ç”¨é»˜è®¤å ä½ç¬¦
                addPhoto(createTextTexture(`Memory ${i+1}`), i);
            }
        }

        // æ–‡ä»¶ä¸Šä¼ å¤„ç†
        document.getElementById('file-upload').addEventListener('change', (e) => {
            const files = e.target.files;
            if(!files.length) return;

            // ç§»é™¤æ—§çš„é»˜è®¤ç…§ç‰‡ï¼ˆå¯é€‰ï¼Œè¿™é‡Œä¸ºäº†æ¼”ç¤ºä¿ç•™å åŠ ï¼‰
            
            Array.from(files).forEach((file, i) => {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.src = ev.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.needsUpdate = true;
                        tex.colorSpace = THREE.SRGBColorSpace;
                        addPhoto(tex, i);
                    };
                };
                reader.readAsDataURL(file);
            });
        });

        // --- 5. MediaPipe Hands é€»è¾‘ ---
        const videoElement = document.getElementById('video-input');
        const statusText = document.getElementById('status-text');

        function onResults(results) {
            document.getElementById('loading-screen').style.opacity = '0';
            setTimeout(() => document.getElementById('loading-screen').style.display = 'none', 1000);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                STATE.handDetected = true;
                const landmarks = results.multiHandLandmarks[0];

                // 1. è®¡ç®—æ‰‹æŒæ˜¯å¦å¼ å¼€ (ç®€å•ç®—æ³•ï¼šæŒ‡å°–åˆ°æ‰‹æŒæ ¹éƒ¨çš„å¹³å‡è·ç¦»)
                const wrist = landmarks[0];
                const tips = [4, 8, 12, 16, 20]; // æŒ‡å°–ç´¢å¼•
                let avgDist = 0;
                tips.forEach(idx => {
                    const dx = landmarks[idx].x - wrist.x;
                    const dy = landmarks[idx].y - wrist.y;
                    avgDist += Math.sqrt(dx*dx + dy*dy);
                });
                avgDist /= 5;

                // 2. æåˆæ£€æµ‹ (é£ŸæŒ‡æŒ‡å°–ä¸å¤§æ‹‡æŒ‡æŒ‡å°–è·ç¦»)
                const pinchDist = Math.sqrt(
                    Math.pow(landmarks[8].x - landmarks[4].x, 2) + 
                    Math.pow(landmarks[8].y - landmarks[4].y, 2)
                );

                // 3. æ˜ å°„æ‰‹çš„ä½ç½®åˆ°æ—‹è½¬
                // MediaPipe x: 0(left) -> 1(right), y: 0(top) -> 1(bottom)
                // ç¿»è½¬Xä»¥åŒ¹é…é•œåƒè§†é¢‘
                const handX = 1.0 - landmarks[9].x; 
                const handY = landmarks[9].y;

                // --- çŠ¶æ€æœºé€»è¾‘ ---
                
                // æåˆåˆ¤æ–­ (ä¼˜å…ˆçº§æœ€é«˜)
                if (pinchDist < 0.05) {
                    if (STATE.current !== 'ZOOM') {
                        STATE.current = 'ZOOM';
                        statusText.innerText = "çŠ¶æ€: ğŸ“¸ å›å¿†èšç„¦";
                        statusText.style.borderColor = "#D4AF37";
                        // éšæœºé€‰ä¸€å¼ ç…§ç‰‡
                        STATE.zoomPhotoIndex = Math.floor(Math.random() * photoMeshes.length);
                    }
                } 
                // å¼ å¼€åˆ¤æ–­
                else if (avgDist > 0.35) { // é˜ˆå€¼éœ€è¦æ ¹æ®å®é™…è°ƒæ•´
                    if (STATE.current !== 'SCATTER') {
                        STATE.current = 'SCATTER';
                        statusText.innerText = "çŠ¶æ€: âœ¨ æ¼«å¤©æ˜Ÿäº‘";
                        statusText.style.borderColor = "#FFF";
                    }
                    
                    // åœ¨æ•£å¼€æ¨¡å¼ä¸‹ï¼Œæ‰‹éƒ¨ç§»åŠ¨æ§åˆ¶æ—‹è½¬
                    STATE.targetRotation.y = (handX - 0.5) * 2; // -1 to 1
                    STATE.targetRotation.x = (handY - 0.5) * 1; 
                } 
                // æ¡æ‹³åˆ¤æ–­ (è·ç¦»å¾ˆå°)
                else if (avgDist < 0.25) {
                    if (STATE.current !== 'TREE') {
                        STATE.current = 'TREE';
                        statusText.innerText = "çŠ¶æ€: ğŸ„ åœ£è¯æ ‘";
                        statusText.style.borderColor = "#2F4F2F";
                    }
                }

            } else {
                STATE.handDetected = false;
                statusText.innerText = "æœªæ£€æµ‹åˆ°æ‰‹åŠ¿";
                // æ— æ‰‹åŠ¿æ—¶æ…¢æ…¢è‡ªåŠ¨æ—‹è½¬
                STATE.targetRotation.y += 0.001; 
            }
        }

        // åˆå§‹åŒ– MediaPipe
        async function setupMediaPipe() {
            // æ³¨æ„ï¼šç”±äºæˆ‘ä»¬åœ¨ Head ä¸­ä½¿ç”¨äº† Script æ ‡ç­¾å¼•å…¥ï¼ŒHands å’Œ Camera ç°åœ¨æ˜¯å…¨å±€å¯¹è±¡ã€‚
            // ä¸å†éœ€è¦ import(...)ï¼Œç›´æ¥ä½¿ç”¨ window.Hands æˆ–è€… Hands å³å¯ã€‚

            if (typeof Hands === 'undefined' || typeof Camera === 'undefined') {
                console.error("MediaPipe åº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚");
                statusText.innerText = "åº“åŠ è½½å¤±è´¥";
                return;
            }

            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            hands.onResults(onResults);

            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });
            camera.start();
        }

        setupMediaPipe();

        // --- 6. åŠ¨ç”»å¾ªç¯ä¸æ’å€¼ ---

        const clock = new THREE.Clock();
        const lerpSpeed = 0.05; // ç§»åŠ¨å¹³æ»‘åº¦

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. ç»„æ—‹è½¬å¹³æ»‘æ’å€¼
            if (STATE.current === 'SCATTER' || STATE.current === 'ZOOM') {
                // æ‰‹åŠ¿æ§åˆ¶çš„æ—‹è½¬
                treeGroup.rotation.y += (STATE.targetRotation.y - treeGroup.rotation.y) * 0.05;
                treeGroup.rotation.x += (STATE.targetRotation.x - treeGroup.rotation.x) * 0.05;
            } else {
                // æ ‘æ¨¡å¼ä¸‹è‡ªåŠ¨è‡ªè½¬
                treeGroup.rotation.y += 0.005;
                treeGroup.rotation.x += (0 - treeGroup.rotation.x) * 0.1; // å›æ­£Xè½´
            }

            // 2. ç²’å­ä½ç½®æ›´æ–°
            objects.forEach((obj, idx) => {
                let target;
                
                // ç¡®å®šç›®æ ‡ä½ç½®
                if (STATE.current === 'TREE') {
                    target = obj.userData.treePos;
                    // è®©ç…§ç‰‡åœ¨æ ‘ä¸Šæ—¶é¢å‘å¤–ä¾§ï¼Œé€šè¿‡ lookAt (éœ€è¦å…ˆç§»åŠ¨å†æ—‹è½¬ï¼Œè¿™é‡Œç®€åŒ–ä¸ºæ¯å¸§è®¡ç®—)
                    if (obj.userData.isPhoto) {
                        obj.lookAt(new THREE.Vector3(0, obj.position.y, 0)); 
                    }
                    if (obj.userData.isPhoto) {
                        obj.scale.setScalar(THREE.MathUtils.lerp(obj.scale.x, 1, 0.1));
                    }
                } else if (STATE.current === 'SCATTER') {
                    target = obj.userData.scatterPos;
                    // æ•£å¼€æ—¶åŠ ä¸Šä¸€ç‚¹æ­£å¼¦æ³¢æµ®åŠ¨
                    target = target.clone();
                    target.y += Math.sin(time + idx) * 0.5;
                    
                    if (obj.userData.isPhoto) {
                        obj.lookAt(camera.position); // ç…§ç‰‡å§‹ç»ˆé¢å‘ç›¸æœº
                        obj.scale.setScalar(THREE.MathUtils.lerp(obj.scale.x, 1, 0.1));
                    }
                } else if (STATE.current === 'ZOOM') {
                    // å¦‚æœæ˜¯é€‰ä¸­çš„ç…§ç‰‡
                    if (obj.userData.isPhoto && photoMeshes[STATE.zoomPhotoIndex] === obj) {
                        // è®¡ç®—ç›¸æœºå‰æ–¹çš„ä½ç½® (æŠŠç…§ç‰‡æ‹‰åˆ°ç›¸æœºé¢å‰)
                        // å°†ä¸–ç•Œåæ ‡è½¬ä¸ºæœ¬åœ°åæ ‡æœ‰ç‚¹éº»çƒ¦ï¼Œç®€å•åšæ³•æ˜¯æŠŠç…§ç‰‡æ”¾åˆ°ç»„çš„ä¸­å¿ƒï¼Œç„¶åå¾€ç›¸æœºæ–¹å‘ç§»
                        // ä½†è¿™é‡Œæˆ‘ä»¬æ˜¯åœ¨ç»„å†…ç§»åŠ¨ã€‚
                        // ç­–ç•¥ï¼šæ‰€æœ‰éé€‰ä¸­ç‰©ä½“æ•£å¼€ï¼Œé€‰ä¸­ç‰©ä½“ç§»å‘ (0,0,20) æœ¬åœ°åæ ‡
                        
                        // ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬è®©é€‰ä¸­ç…§ç‰‡é£åˆ° Group çš„å‰æ–¹ï¼Œå¹¶æ”¾å¤§
                        const viewPos = new THREE.Vector3(0, 0, 30).applyMatrix4(treeGroup.matrixWorld.clone().invert());
                        target = viewPos;
                        
                        obj.lookAt(camera.position);
                        obj.scale.setScalar(THREE.MathUtils.lerp(obj.scale.x, 3.5, 0.1)); // æ”¾å¤§
                    } else {
                        // å…¶ä»–ç‰©ä½“æ¨è¿œæˆ–æ•£å¼€
                        target = obj.userData.scatterPos.clone().multiplyScalar(1.5);
                    }
                }

                // æ‰§è¡Œä½ç½®æ’å€¼
                obj.position.lerp(target, lerpSpeed);
            });

            // æ¸²æŸ“
            composer.render();
        }

        // çª—å£è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>